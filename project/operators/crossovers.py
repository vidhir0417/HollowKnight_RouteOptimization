from base.individuals import *
import random

def cycle_crossover(individual1, individual2):
    """
    Execute cycle crossover on two parent sequences to produce offspring,
    incorporating pre- and post-crossover operations.

    This genetic algorithm technique preserves gene order and content from
    the parents into the offspring by finding cycles between the parents.

    Args:
        individual1 (list): The first parent genome sequence.
        individual2 (list): The second parent genome sequence.

    Returns:
        tuple: Contains two offspring created by cycle crossover.
    """

    # Apply pre-operation modifications to the parents
    parent1 = pre_operations(individual1.copy())
    parent2 = pre_operations(individual2.copy())

    # Compute the number of elements in each parent genome
    size = len(parent1)

    # Initialize the start position for cycle detection (should be randomized in production)
    start = 0


    def generate_cycle_crossover(parent1, parent2, size, start_index):
        """
        Implement a single cycle crossover between two parent genomes to produce one offspring.

        The function uses cycle detection starting from the given index, copying elements
        from parent1 into the offspring. Remaining elements are filled from parent2 to
        complete the genome without duplications.

        Args:
            parent1 (list): The primary parent for gene sourcing.
            parent2 (list): The secondary parent for gene sourcing.
            size (int): Number of genes in each parent genome.
            start_index (int): Starting index for the cycle crossover.

        Returns:
            list: A new offspring genome resulting from the cycle crossover.
        """

        # Track which positions have been filled in the offspring
        filled_positions = set()

        # Initialize the offspring array with None to signify unfilled positions
        offspring = [None] * size

        while True:

            # Place the gene from parent1 into the current position of the offspring
            offspring[start_index] = parent1[start_index]

            # Mark this position as filled
            filled_positions.add(start_index)

            # Determine the next index using the corresponding gene from parent2
            next_gene = parent2[start_index]

            if next_gene in parent1:

                next_index = parent1.index(next_gene)

            else:

                # If the gene from parent2 doesn't exist in parent1, move to the next gene in the cycle
                next_index = (start_index + 1) % size

                # A flag to indicate whether a suitable index has been found
                found = False 

                # Limit to 'size' attempts
                for attempt in range(size):
                    if next_index not in filled_positions:

                        found = True
                        break

                    next_index = (next_index + 1) % size

            # Update the start index for the next cycle iteration
            start_index = next_index

            # Check if the cycle is complete (i.e., we've returned to a filled position)
            if start_index in filled_positions:
                break

        # Fill any unfilled positions in the offspring with genes from parent2
        for i in range(size):
            if offspring[i] is None:

                offspring[i] = parent2[i]

        return offspring

    # Generate two offspring by invoking the helper function with swapped roles for parents
    offspring1 = generate_cycle_crossover(parent1, parent2, size, start)
    offspring2 = generate_cycle_crossover(parent2, parent1, size, start)

    # Apply post-operation modifications to the offspring
    offspring1 = post_operations(offspring1)
    offspring2 = post_operations(offspring2)

    # Fix placeholders in the offspring
    offspring1 = fix_placeholder(offspring1)
    offspring2 = fix_placeholder(offspring2)

    return (offspring1, offspring2)


def pmx_crossover(individual1, individual2):
    """
    Executes Partially Mapped Crossover (PMX) between two individuals to produce two offsprings.
    This function involves selecting a crossover segment from one parent and filling in the remaining elements
    from the other parent while preserving the relative order and ensuring each element appears only once.

    Args: 

        individual1 (list): The first individual genome or list.
        individual2 (list): The second individual genome or list.

    Returns:
        tuple: Contains two offspring generated by the PMX crossover process, 
               after applying pre- and post-operations to modify the genome sequences.
    """

    size = len(individual1)
    start = random.randint(0, size - 1)
    end = random.randint(start + 1, size)

    offspring1 = [None] * size
    offspring2 = [None] * size

    offspring1[start:end] = individual1[start:end]
    offspring2[start:end] = individual2[start:end]

    for i in range(start, end):

        element1 = individual2[i]
        element2 = individual1[i]

        # Place element1 from individual2 into offspring1 if it's not already present
        if element1 not in offspring1:

            index = -1

            for j in range(size):
                if individual1[j] == element1:

                    index = j
                    break

            if index != -1:

                # Find the first available position for the element
                while offspring1[index] is not None:
                    for k in range(size):
                        if individual1[k] == individual2[index]:

                            index = k
                            break
                    else:

                        # Breaks the while if no valid index found
                        index = -1  
                        break

                if index != -1 and offspring1[index] is None:

                    offspring1[index] = element1

        # Place element2 from individual1 into offspring2 if it's not already present
        if element2 not in offspring2:

            index = -1

            for j in range(size):
                if individual2[j] == element2:

                    index = j
                    break

            if index != -1:

                # Find the first available position for the element
                while offspring2[index] is not None:
                    for k in range(size):
                        if individual2[k] == individual1[index]:

                            index = k
                            break

                    else:

                        # Breaks the while if no valid index found
                        index = -1
                        break

                if index != -1 and offspring2[index] is None:

                    offspring2[index] = element2

    # Replace None values
    for i in range(size):
        offspring1[i] = offspring1[i] if offspring1[i] is not None else individual2[i]
        offspring2[i] = offspring2[i] if offspring2[i] is not None else individual1[i]

    # Apply post-operation modifications and potential placeholder corrections to the offspring
    offspring1 = post_operations(offspring1)
    offspring2 = post_operations(offspring2)
    offspring1 = fix_placeholder(offspring1)
    offspring2 = fix_placeholder(offspring2)

    return offspring1, offspring2


def ox1_crossover(individual1, individual2):
    """
    Execute an Order Crossover (OX1) between two individual genomes.

    This function implements the OX1 crossover genetic algorithm, which is useful for
    preserving relative order of elements from the parents in the offspring. It involves
    selecting a subtour from one parent and maintaining the order and position of as many
    elements as possible from the other parent.

    Args:
        individual1 (list): The first individual genome or list.
        individual2 (list): The second individual genome or list.

    Returns:
        tuple: Contains two offspring generated by the OX1 crossover process, 
               after applying pre- and post-operations to modify the genome sequences.
    """

    # Define the parents, applying initial modifications
    parent1 = pre_operations(individual1.copy())
    parent2 = pre_operations(individual2.copy())

    # Determine the number of elements in the genomes
    size = len(parent1)

    # Select two random cut points to define the crossover region
    cut_points = sorted(random.sample(range(1, size), 2))

    # Initialize offspring lists with placeholder values
    offspring1 = [0] * size
    offspring2 = [0] * size

    # Copy the selected subtour from parent1 to offspring1
    offspring1[cut_points[0]:cut_points[1]] = parent1[cut_points[0]:cut_points[1]]
    child1_substring = offspring1[cut_points[0]:cut_points[1]]

    # Copy the selected subtour from parent2 to offspring2
    offspring2[cut_points[0]:cut_points[1]] = parent2[cut_points[0]:cut_points[1]]
    child2_substring = offspring2[cut_points[0]:cut_points[1]]

    # Fill in the remaining positions in offspring1 with elements from parent2, excluding those in the subtour
    remaining = [room for room in parent2 if room not in child1_substring]
    index = cut_points[1]

    for room in remaining:

        offspring1[index] = room
        index = (index + 1) % size

    # Similarly, fill in the remaining positions in offspring2 with elements from parent1
    remaining2 = [room for room in parent1 if room not in child2_substring]
    index = cut_points[1]

    for room in remaining2:

        offspring2[index] = room
        index = (index + 1) % size

     # Apply post-operation modifications and potential placeholder corrections to the offspring
    offspring1 = post_operations(offspring1)
    offspring2 = post_operations(offspring2)
    offspring1 = fix_placeholder(offspring1)
    offspring2 = fix_placeholder(offspring2)


    return offspring1, offspring2



def uniform_crossover(individual1, individual2):
    """
    Performs Uniform Crossover between two parent individuals, incorporating pre- and post-crossover operations.

    Args:
        individual1 (list): The first parent individual.
        individual2 (list): The second parent individual.

    Returns:
        tuple: A tuple containing two offspring individuals resulting from the Uniform Crossover operation.
    """

    # Apply pre-operation modifications to the parents
    parent1 = pre_operations(individual1.copy())
    parent2 = pre_operations(individual2.copy())

    size = len(parent1)
    offspring1 = []
    offspring2 = []

    for i in range(size):
        if random.choice([True, False]):

            offspring1.append(parent1[i])
            offspring2.append(parent2[i])
            
        else:

            offspring1.append(parent2[i])
            offspring2.append(parent1[i])

    # Apply post-operation modifications and potential placeholder corrections to the offspring
    offspring1 = post_operations(offspring1)
    offspring2 = post_operations(offspring2)
    offspring1 = fix_placeholder(offspring1)
    offspring2 = fix_placeholder(offspring2)


    return offspring1, offspring2





